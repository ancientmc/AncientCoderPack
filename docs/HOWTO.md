## How to use ACP ##

### Setting up ###
It's recommended to download ACP from the releases tab. If you want to download ACP from the "Code" button on GitHub, that's fine, 
but make sure to rename the parent folder of the project files to "AncientCoderPack", otherwise it will not work (you can also
git-clone it, which will eliminate this problem).

Before doing anything, you need to download JDK 8 and JDK 17. ACP is built against Java 8, and the majority of its processes, including Minecraft, 
are using that version. However, Enigma, the program used for parameter mapping, is built against Java 17, so you need that version as well.

There are a variety of different JDK vendors you can find that will suit your needs. Here are some links to Temurin 
provided by Eclipse Adoptium.

Java 8: https://adoptium.net/temurin/releases/?version=8
Java 17: https://adoptium.net/temurin/releases/?version=17

You don't need to worry about what JDK you have set for your IDE and for Gradle; Most ACP tasks run fine regardless of either version,
and any ACP task that needs a specific Java version is already configured to call that version. Just make sure you have the versions 
listed above installed on your device and path (Gradle should auto-detect them). If you're unsure, run the "javaToolchains" task 
in the "help" group. This task lists the JDKs Gradle recognizes; if the versions you just installed are there, you're good to go.

Gradle will initialize as soon as the project is imported. This shouldn’t take more than a minute or so. 
All it’s doing is downloading the ACP-Gradle jar, downloading the version JSON, and downloading Minecraft's libraries into your classpath.

Once that’s done, you can get started working with ACP.

### Decompiling ###
To decompile, you can run the “setup” task that’s ¾ of the way down in the build.gradle file, or in the Gradle task group window 
under “acp-run”. ACP will then begin to decompile the source code. This should, on average, take about a minute or two. The first time will take 
longer (but not by much), because it needs to install the external tools, such as RetroGuard and Enigma. 

Note that you will see some errors once the "decompileClassFiles" task gets executed. These are just some warnings Quiltflower
throws at you. Everything is still running fine, and the code should decompile successfully.

After the process has been completed, the source code is ready to browse. To run the game, click the “runClient” task, which can either be
found in the "acp-run" task group, or under the "setup" task in the buildscript.

### Recompiling ###
To reobfuscate the code, click the "reobf" jar in the "acp-reobf" task group. This will compile and reobfuscate the output jar file found in 
the "build/libs" directory. As a reminder, do not publish any full Minecraft jar, modified or not, that has been generated by ACP.

Note that RetroGuard will spit out some errors regarding synthetic array fields in the Enum classes. These errors occur because the "jar" task
technically "obfuscates" these arrays upon compilation (they get replaced with a generic "$VALUES" name). As a result, RetroGuard cannot read them
during reobfuscation. You don't need to worry about this; everything else should reobfuscate correctly.

### Generating BinPatches ###
If you are directly modifying the jar, ACP provides a task that allows you to generate binary patches using Minecraft Forge's BinaryPatcher. 
The "genBinPatches" task can be found in the buildscript under the intermediary "jar" task, or in the "modtools" group in the Gradle task window. 
The output will be found in the build directory, inside "modding/patches/bin/client.lzma".

### Applying BinPatches ###
For applying patches, you'll need to download BinaryPatcher. Forge doesn't directly provide a way to download the BinaryPatcher tool 
from their site, for whatever reason, but you can still use their maven to get it:
https://maven.minecraftforge.net/net/minecraftforge/binarypatcher/1.1.1/binarypatcher-1.1.1-fatjar.jar

Once you have this, run the jar via command line and use the following format:

```
java -jar {BINPATCH_TOOL} --clean {VANILLA_JAR} --apply {PATCH_LZMA} --output {MODDED_JAR}
```

Where BINPATCH_TOOL is the BinaryPatcher JAR, VANILLA_JAR is the vanilla Minecraft Alpha 1.2.6 jar, PATCH_LZMA is the LZMA 
file generated from the genBinPatches task, and MODDED_JAR is the outputted modified jar you wish to run in your launcher.

### Generating DiffPatches ###
BinPatches aren't viewable in a text editor, so ACP gives you the option to generate DiffPatch files (.patch) so you can 
easily show your changes to the code on GitHub. Under the "genBinPatches" task you can find the "genDiffPatches" task 
(it's also found in the "modtools" task group) Running this task will generate patches in the build directory, inside 
"modding/patches/diff/".

These won't serve any real purpose other than making your code changes visible, as you'll need BinPatches to actually
make changes to the Minecraft jar.